[ { "title": "RevyOS 学习日志", "url": "/posts/RevyOS_Study-notes/", "categories": "Development, Embedded", "tags": "RevyOS, LicheePi4A", "date": "2025-02-18 00:00:00 +0800", "snippet": "介绍 RevyOS：由 RuyiSDK 团队的 RevyOS 小队支持开发的一款针对 XuanTie 芯片生态的 Debian 优化定制发行版。[了解更多] Lichee Pi 4A：使用了 Lichee Module 4A 核心板组合出来的 Linux 开发板，以 TH1520 为主控核心，搭载 4TOPS@int8 AI 算力的 NPU，支持双屏 4K 显示输出，支持 4K 摄像头接...", "content": "介绍 RevyOS：由 RuyiSDK 团队的 RevyOS 小队支持开发的一款针对 XuanTie 芯片生态的 Debian 优化定制发行版。[了解更多] Lichee Pi 4A：使用了 Lichee Module 4A 核心板组合出来的 Linux 开发板，以 TH1520 为主控核心，搭载 4TOPS@int8 AI 算力的 NPU，支持双屏 4K 显示输出，支持 4K 摄像头接入，双千兆 POE 网口和多个 USB 接口，音频由 C906 核心处理。[了解更多]" }, { "title": "利用 OpenMV 实现 AprilTag 跟踪以及通过串口通讯控制 Arduino 驱动 LED 灯带", "url": "/posts/LEDFollower_Project/", "categories": "Development, Embedded", "tags": "站点更新日志", "date": "2024-05-31 00:00:00 +0800", "snippet": " （2024-06-28 更新） 在开放源码（详见文末）之外，我也制作了一个简单的介绍视频放在 Bilibili，欢迎对项目和具体代码实现思路感兴趣的朋友们前去查看！若有需要改进之处也恳请指正！项目介绍此项目为本人在参与Vision Board 创客营活动第二阶段（应用作品设计）过程中所产出的内容。主要内容是实现 LED 矩阵实时响应 AprilTag 的坐标进行同步移动。实现方案总共涉及...", "content": " （2024-06-28 更新） 在开放源码（详见文末）之外，我也制作了一个简单的介绍视频放在 Bilibili，欢迎对项目和具体代码实现思路感兴趣的朋友们前去查看！若有需要改进之处也恳请指正！项目介绍此项目为本人在参与Vision Board 创客营活动第二阶段（应用作品设计）过程中所产出的内容。主要内容是实现 LED 矩阵实时响应 AprilTag 的坐标进行同步移动。实现方案总共涉及三款硬件，具体内容为：使用 Vision Board 作为上位机，并通过 OpenMV 程序获取 AprilTag 实时坐标、再通过 UART 串口通讯发送坐标信息给下位机；Arduino Uno 作为下位机接收坐标信息并将信息转化为 LED 矩阵坐标，再通过 FastLED 库实现对 WS2812b 灯带的 LED 操控。开发现况 由于手头上的 WS2812b 灯带连接触点氧化、无法焊接导线从而成为方形矩阵，故暂时放弃二维矩阵的模式，转而以初步实现一维矩阵（5 个 LED 灯珠）为目标。 由于手头上持有的 BLE-Nano 是以蓝牙功能为卖点的设备，故蓝牙串口与 UART 串口之间可能存在某种冲突而无法正确接收 UART 串口协议信号。但是经过 USB 转 TTL 模块验证，Vision Board 可以正常通过串口输出，连线图以及输出效果如下图所示：后面有空的话再研究一下 BLE-Nano，再不行就换一块 Arduino 板子。目前来看，不妨将这个半成品作为一种 API 般的存在吧…（虽然这个半成品的实现门槛很低就是了） （2024-06-25 更新）：通过更换下位机为 Arduino Uno 板子并对两端程序进行补充与修复，成功实现一维 LED 矩阵的跟踪功能，下面附上连线图与效果图：待办 / TODO 调通上位机与下位机之间的 UART 通讯 当识别不同编号的 AprilTag 时，灯带发出不同颜色 实现二维 LED 矩阵形式的跟踪效果 我也将 OpenMV 以及 Arduino 工程文件开源在 GitHub，欢迎对该项目感兴趣的朋友们前来指正以及补充。权当抛砖引玉，恳请各位不吝赐教！" }, { "title": "RA8D1 Vision Board 实现 FAL 同时调用片上以及外挂 Flash", "url": "/posts/FAL4SPI-Flash_TestProject/", "categories": "Development, Embedded", "tags": "站点更新日志", "date": "2024-04-24 00:00:00 +0800", "snippet": " 使用软件： RT-Thread Studio 2.2.7 -&gt; 工程创建与编辑 FSP Smart Configurator 23.10.0 (FSP Version: 5.1.0) -&gt; 配置和管理 RA8D1 芯片 MobaXterm Personal Edition V24.0 -&gt; 串口终端 测试内容：QSPI...", "content": " 使用软件： RT-Thread Studio 2.2.7 -&gt; 工程创建与编辑 FSP Smart Configurator 23.10.0 (FSP Version: 5.1.0) -&gt; 配置和管理 RA8D1 芯片 MobaXterm Personal Edition V24.0 -&gt; 串口终端 测试内容：QSPI-FLASH（fal+文件系统） 测试对象：8 MB QSPI-FLASH（型号：W25Q64JV）1 环境搭建 主要参考 RT-Thread 文档中心以及官方创建的腾讯在线文档1.1 遇到的问题及解决方案在官方文档的指引下，安装过程本是一路顺风，最后却卡在了 RT-Thread Studio 的 .exe 安装步骤。 错误现象：双击或右键管理员打开 .exe 文件均无反应 解决办法：本来以为需要研究用户组策略等问题，但最后无意间发现，只需要右键 .exe 文件进入属性页，勾选“解除锁定”复选框即可…2 启用 FAL 组件并同时调用 片上&amp;外挂 Flash 初次接触 RT-Thread，进度比大家慢，因此也获得了参考前辈们经验的机会，在此表达敬意！ 参考资料： RT-Thread 使用FAL多字节读写FLASH（作者：嵌入式大杂烩） RT-Thread FAL 组件使用（作者：tang_jia） W25Q64JV 官方手册 【Vision Board创客营连载体验】RA8D1 Vision Board上的SPI实践（作者：大菠萝Alpha） 2.1 配置 RT-Thread Settings 首页：Drivers 启用串口、Pin、SPI、SFUD： 组件页：设置如下： 硬件页：启用 Onchip FLASH、SPI1 BUS： 2.2 配置 RASC Stacks：启用 g_spi1 SPI(r_spi_b)、g_flash FLASH(g_flash_hp) 栈：这里需要注意，两个栈的具体设置需要与代码对齐： Pins：配置 SPI1 相关引脚（注：也是因为这里 SPI0 的引脚设置不好，前面才选择启用 SPI1 BUS，原因不详，若有了解、请指教！） 最后创建相关文件即可！RASC 光荣退休！（不是）2.3 代码编写 我这里将 SPI 初始化行为独立成了一个 spi_init.c 文件存放在 /src 路径： #include &lt;rtthread.h&gt; #include &lt;rtdevice.h&gt; #include \"hal_data.h\" #define SPI_NAME \"spi10\" #define CS_PIN BSP_IO_PORT_04_PIN_13 static struct rt_spi_device *spi_dev; static int rt_spi_device_init(void){ struct rt_spi_configuration cfg; rt_hw_spi_device_attach(\"spi1\", SPI_NAME, CS_PIN); cfg.data_width = 8; cfg.max_hz = 1 * 1000 * 1000; spi_dev = (struct rt_spi_device *)rt_device_find(SPI_NAME); if (RT_NULL == spi_dev){ rt_kprintf(\"Can't find spi device named %s\", SPI_NAME); return -RT_ERROR; } rt_spi_configure(spi_dev, &amp;cfg); return RT_EOK; } INIT_APP_EXPORT(rt_spi_device_init); 然后在 /board/ports/fal_cfg.h 文件中定义设备表与分区表，我这里将 BootLoader 和 APP 放在片上 Flash，外挂 Flash 单独分区： #ifndef _FAL_CFG_H_ #define _FAL_CFG_H_ #include \"hal_data.h\" extern const struct fal_flash_dev _onchip_flash_hp0; extern const struct fal_flash_dev _onchip_flash_hp1; extern struct fal_flash_dev nor_flash0; /* flash device table */ #define FAL_FLASH_DEV_TABLE \\ { \\ &amp;_onchip_flash_hp0, \\ &amp;_onchip_flash_hp1, \\ &amp;nor_flash0, \\ } /* ====================== Partition Configuration ========================== */ #ifdef FAL_PART_HAS_TABLE_CFG /** partition table, The chip flash partition is defined in \"\\ra\\fsp\\src\\bsp\\mcu\\ra6m4\\bsp_feature.h\". * More details can be found in the RA6M4 Group User Manual: Hardware section 47 Flash memory.*/ #define FAL_PART_TABLE \\ { \\ {FAL_PART_MAGIC_WROD, \"boot\", \"onchip_flash_hp0\", 0, BSP_FEATURE_FLASH_HP_CF_REGION0_SIZE, 0}, \\ {FAL_PART_MAGIC_WROD, \"app\", \"onchip_flash_hp1\", 0, (BSP_ROM_SIZE_BYTES - BSP_FEATURE_FLASH_HP_CF_REGION0_SIZE), 0}, \\ {FAL_PART_MAGIC_WROD, \"disk\", \"W25Q64\", 0, (BSP_DATA_FLASH_SIZE_BYTES), 0}, \\ } #endif /* FAL_PART_HAS_TABLE_CFG */ #endif /* _FAL_CFG_H_ */ 最后在 /src/hal_entry.c 内进行 fal 的初始化即可： #include &lt;rtthread.h&gt; #include &lt;rtdevice.h&gt; #include \"hal_data.h\" void hal_entry(void) { rt_kprintf(\"\\nHello RT-Thread!\\n\"); fal_init(); } 2.4 效果展示 这里不理解为何会有一个报错，明明 fal probe 能探到，且 list device 也有 W25Q64…如果搞懂了我会实时更新文章！我也将最后的工程文件开源在 个人 GitHub 仓库 上，欢迎各位来抓虫~3 文件系统的搭建未完待续，敬请期待！" }, { "title": "模电学习笔记：常用半导体器件（不定期更新中）", "url": "/posts/note4AET_Semiconductor/", "categories": "Basic Subject, Analog Electronics", "tags": "模电", "date": "2023-04-17 00:00:00 +0800", "snippet": " 模电基础薄弱，需要从头学习一遍。借助费曼学习法原理，以输出倒逼输入。若有不正确的地方，欢迎在评论区指出，感激不尽！BJT 相关判断 BJT 引脚的方法根据所给两个引脚的电流判断注：这里一般题设为“已知放大电路中管子两个电极的电流”，所以默认管子处于放大状态。① 由 $I_e=I_c+I_b=(β+1)*I_b$，假设 $β»1$，则 $I_e≈I_c$，故电流量微弱侧为 $I_b$；② ...", "content": " 模电基础薄弱，需要从头学习一遍。借助费曼学习法原理，以输出倒逼输入。若有不正确的地方，欢迎在评论区指出，感激不尽！BJT 相关判断 BJT 引脚的方法根据所给两个引脚的电流判断注：这里一般题设为“已知放大电路中管子两个电极的电流”，所以默认管子处于放大状态。① 由 $I_e=I_c+I_b=(β+1)*I_b$，假设 $β»1$，则 $I_e≈I_c$，故电流量微弱侧为 $I_b$；② 根据 $I_b$ 电流流向判断 BJT 类型为 NPN 或 PNP；③ 通过题设条件中另一个引脚的电流方向区分集电极 c 与发射极 e。根据所给三个引脚的直流电位判断注：这里一般题设为“已知放大电路中管子的直流电位”，所以默认管子处于放大状态。① 因为管子工作在放大状态，所以发射极 e 与基极 b 的直流电位相近，剩下的就是集电极 c；② 若集电极 c 的电位最高，则为 NPN 型管，电位最低的为发射极 e，电位居中的基极 b；否则为 PNP 管，电位最高的为发射极 e，电位居中的为基极 b；③ 一般默认硅管的导通电压 $U_{ce}$ 为 0.6~0.8V，锗管的导通电压 $U_{ce}$ 为 0.1~0.3V。 参考资料: 《电子技术基础模拟部分（第六版）》- 康华光 《模拟电子技术基础（第五版）》- 童诗白 " }, { "title": "本站点更新日志", "url": "/posts/web_update_log/", "categories": "misc", "tags": "站点更新日志", "date": "2021-02-14 00:00:00 +0800", "snippet": " 请注意：原先使用的 lwantaoo.xyz 域名已在弃用后被他人恶意抢注，与本人无任何关联。站点概况表格内容更新于 2023.12.02 (UTC+8) 框架 主题 部署方式 域名解析 Jekyll Chirpy by cotes2020 Vercel blog.vant...", "content": " 请注意：原先使用的 lwantaoo.xyz 域名已在弃用后被他人恶意抢注，与本人无任何关联。站点概况表格内容更新于 2023.12.02 (UTC+8) 框架 主题 部署方式 域名解析 Jekyll Chirpy by cotes2020 Vercel blog.vantao.cn 版本更新历史内容被划线，即表示其“随着版本更新而失去作用”。2023 Patch 6 (03-11) 为了增强博客的阅读体验，将主题更换为 Aomori,感谢 lh1me 的开源项目 Patch 7 (04-04) 为了能够与访问博客的朋友们交流探讨，引入了 Giscus 作为博客的评论系统 Patch 8 (04-30) 将域名更换为更简短的 vantao.cn 为博客引入了 RSS，默认为 atom 类型，也同时生成了 rss2 类型 Patch 9 (08-25) 将博客从 Hexo 迁移至 Hugo Patch 10 (12-02) 将博客从 Hugo 迁移至 Jekyll 我真是个花心大萝卜（ 2022 Patch 3 (03-18) 为了提升访问速度，添加 Vercel 作为额外的部署平台 Patch 4 (04-30) 购买域名 lwantaoo.xyz，将 me.* 解析至 Vercel 的部署页面，而 GitHub 部署页面则使用 aokivan.github.io Patch 5 (06-14) 国内域名解析更换为 blog.lwantaoo.xyz，原链接作为博客和其他站点的中转站2021 Patch 1 (02-14) 基于 Hexo，托管于 Gitee 平台的个人博客项目诞生 Patch 2 (08-10) 为了将项目转移至 GitHub 平台" } ]
